from db_management import AuditLogging
import discord
from discord import app_commands
from discord.ext import commands
from nbot import return_db_connection, GUILD_ID
from secret import admin_role_command_text
import io

class AdminCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @app_commands.command(
        name='generate_logs',
        description="Returns logs by optional parameters, only usable by admins."
    )
    @app_commands.guilds(GUILD_ID)
    @app_commands.choices(command_type=[ # default list of options for 'command_type' field when it's being built by the user.
        app_commands.Choice(name="register_player", value="register_player"),
        app_commands.Choice(name="create_character", value="create_character"),
        app_commands.Choice(name="rename_character", value="rename_character"),
        app_commands.Choice(name="delete_character", value="delete_character"),
        app_commands.Choice(name="remove_xp", value="remove_xp"),
        app_commands.Choice(name="set_level_of_character", value="set_level_of_character"),       
        app_commands.Choice(name="see_my_characters", value="see_my_characters"),
        app_commands.Choice(name="add_tupper", value="add_tupper"),    
        app_commands.Choice(name="remove_tupper", value="remove_tupper")
    ])
    @app_commands.describe(
        start_date="YYYY-MM-DD",
        end_date="YYYY-MM-DD",
    )
    async def query_logs( 
        self,
        interaction: discord.Interaction,
        user_mention: discord.Member | None = None,
        command_type: str | None = None,
        start_date: str | None = None,
        end_date: str | None = None
    ):
        # Admin check
        if admin_role_command_text not in [role.name for role in interaction.user.roles]: # admin_role_command_text is in secret.py. The name of the role of the invoking user must be in the list of roles they have.
            return await interaction.response.send_message(
                "You do not have permission to use this command."
            )
        
        await interaction.response.defer() # stops discord from assuming the command failed in case it takes a while (which may be the case depending on the amount of rows returned from the database)
        discord_id = interaction.user.id
        conn = await return_db_connection()

        try:
            audit = AuditLogging(discord_id, conn) # create an AuditLogging object 
            target_id = user_mention.id if user_mention else None # get id from user mention if provided, since the sql-lite database does not store user mentions, but discord ids, and if not supplied, optional, so None

            # get list of strings generated by AuditLogging.get_logs

            logs = await audit.get_logs(
                discord_id=target_id,
                command_type=command_type,
                start_date=start_date,
                end_date=end_date
            )

            text = "\n".join(logs) #
            file = discord.File(io.BytesIO(text.encode()), filename="output.txt")

            if logs: # return logs if found, otherwise say no logs found
                await interaction.followup.send("Here are your logs:", file=file)
            else:
                await interaction.followup.send("No logs found.")
        except Exception as e:
            await conn.rollback()
            await interaction.followup.send(f"Error: {e}.")

        await conn.close()

async def setup(bot):
   await bot.add_cog(AdminCommands(bot))


